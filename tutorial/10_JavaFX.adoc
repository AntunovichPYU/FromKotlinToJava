= JavaFX-приложения с графическим интерфейсом

Сегодня мы поговорим о приложениях, созданных с помощью библиотеки JavaFX. Эта библиотека появилась в 2007 году, она предназначена для проектирования приложений с графическим интерфейсом -- как Desktop-приложений (работающих на обычном компьютере), так и Web-приложений (работающих в браузере). Библиотека была призвана заменить GUI-библиотеку предыдущего поколения -- Swing. 

Первые годы JavaFX существовала отдельно от основной платформы Java, и язык для её программирования назывался JavaFX Script. В 2014 году библиотека вошла в состав JDK 1.8 и получила полноценную поддержку со стороны языка Java. В 2018 году при выпуске JDK 11 JavaFX убрали из состава JDK и выделили в https://gluonhq.com/products/javafx/[отдельную библиотеку].

== Поддержка на Java и Kotlin

Библиотека JavaFX входит в состав JDK 1.8, 9 и 10, поэтому для этих JDK программы на Java и Kotlin могут, в принципе, использовать её без подключения дополнительных зависимостей. При использовании JDK 11 и более поздней необходимо явное подключение JavaFX в виде https://gluonhq.com/products/javafx/[загруженного пакета], https://openjfx.io/openjfx-docs/#maven[Maven-зависимости] или https://openjfx.io/openjfx-docs/#gradle[Gradle-зависимости]. Данный проект пока использует JDK 1.8, поэтому JavaFX-зависимость доступна ему непосредственно; загрузить JDK 1.8 можно https://www.oracle.com/java/technologies/javase-jdk8-downloads.html[отсюда].

Для программ на Kotlin существует удобный DSL (Domain Specific Language = предметно-ориентированный язык) https://tornadofx.io[tornadofx] -- см. также https://github.com/edvin/tornadofx[его GitHub-репозиторий]. Этот DSL может быть подключен к программам на Kotlin как дополнительная библиотека -- подробности о подключении дополнительных библиотек см. в https://github.com/Kotlin-Polytech/FromKotlinToJava/tree/master/tutorial/07_Console_Exceptions.adoc[7-м разделе]; опять-таки можно использовать Maven- или Gradle-зависомость, примеры есть https://github.com/edvin/tornadofx[на GitHub в README].

Domain Specific Language позволяет, в частности, описывать структуру JavaFX-сцен в более прозрачной для программиста форме. Вот так, например, выглядит типичное описание диалога с помощью tornadofx (пример взят из https://github.com/Kotlin-Polytech/FromKotlinToJava/blob/master/src/part3/fourinrow/javafx/ChoosePlayerDialog.kt[игры 4 в ряд]).

[source,kotlin]
----
    init {
        title = "Four-in-Row"
        with (dialogPane) {
            headerText = "Choose players"
            buttonTypes.add(ButtonType("Start Game", ButtonBar.ButtonData.OK_DONE))
            buttonTypes.add(ButtonType("Quit", ButtonBar.ButtonData.CANCEL_CLOSE))
            content = hbox {
                vbox {
                    label("Yellow")
                    togglegroup {
                        bind(yellowPlayer)
                        radiobutton("Human") {
                            isSelected = true
                        }
                        radiobutton("Computer")
                    }
                }
                spacer(Priority.ALWAYS)
                vbox {
                    label("Red")
                    togglegroup {
                        bind(redPlayer)
                        radiobutton("Human")
                        radiobutton("Computer") {
                            isSelected = true
                        }
                    }
                }
            }
        }
    }
----

Прочитав этот фрагмент кода, мы можем узнать:

* Диалог называется Choose Players
* Диалог имеет две кнопки, позволяющие его покинуть -- Start Game(OK) и Quit(CANCEL)
* Основная часть диалога -- горизонтальная секция (hbox == horizontal box), состоящая, в свою очередь, из двух вертикальных секций (vbox == vertical box)
* Левая вертикальная секция помечена (label) как Yellow и включает в себя группу из двух радио-кнопок (radiobutton) -- из этих кнопок пользователь всегда сможет выбрать только одну. По умолчанию из кнопок Human и Computer выбрана Human
* Правая вертикальная секция помечена как Red и включает в себя две такие же кнопки, но по умолчанию выбрана Computer

image::../images/dialog.png[Dialog]

== Простое приложение на JavaFX

Как подробно написано в https://www.tutorialspoint.com/javafx/javafx_application.htm[этой статье], JavaFX-приложение стоит на трёх основных китах:

* Stage = Окно приложения
* Scene = Сцена, содержимое окна, описывается графом сцены (Scene Graph)
* Nodes = Отдельные узлы графа сцены

Узлы JaxaFX имеют сложную иерархию. В рамках графа сцены всегда есть корневой узел (root), включающий в себя другие узлы (потомки), которые, в свою очередь, тоже могут иметь потомков, и так до любого уровня вложенности, то есть узлы образуют *дерево*. Кроме этого, отдельные типы узлов образуют иерархию наследования. Например:

* Parent = подвид узла, который может иметь потомков
* Group = подвид Parent, простая обёртка над одним или несколькими другими узлами
* Region = подвид Parent, описывающий *графический компонент* -- элемент графического интерфейса, видимый пользователю и дающий возможность делать с ним какие-то действия. 
* Control = подвид Region, описывающий обычный компонент, не содержащий внутри себя других компонентов. Примером являются Button, ListView, ScrollBar и другие.
* Pane = подвид Region, описывающий панель, состоящую из других упорядоченных компонентов. Примером являются BorderPane, DialogPane, HBox, VBox
* Shape = подвид узла, описывающий разные виды геометрических фигур -- этот элемент интерфейса просто изображается на экране, не предоставляя возможности с ним взаимодействовать. Примером фигур являются Circle, Line, Polygon, Rectangle, Text

Для того, чтобы создать JavaFX-приложение, необходим класс, расширяющий `javafx.application.Application`. Логика создания главного окна задаётся в его методе `start`, будущее окно `Stage` передаётся ему как параметр `primaryStage`. Необходимо, как минимум:

* Создать корневой элемент сцены
* Создать сцену на основе этого элемента и связать её с окном
* Задать заголовок окна
* Показать окно, вызвав его функцию `show`

Все эти действия выполнены ниже, см. также https://github.com/Kotlin-Polytech/FromKotlinToJava/blob/master/src/part3/simple/hello/javafx/HelloJavafx.java[пример].

[source,java]
----
public class HelloJavafx extends Application { 
    @Override     
    public void start(Stage primaryStage) {
        // Создаём корневой элемент сцены
        Group root = new Group(); 
        // Создаём сцену и задаём её размеры
        Scene scene = new Scene(root, 400, 300); 
        // Связываем сцену и окно
        primaryStage.setScene(scene);         
        // Задаём заголовок окну
        primaryStage.setTitle("Hello, JavaFX");     
        // Показываем окно
        primaryStage.show(); 
    }    
    public static void main(String[] args) {          
        // Запускаем JavaFX-приложение
        launch(args);     
    }         
} 
----

== Архитектура GUI-приложений

Когда мы разрабатываем GUI-приложение (GUI = Graphical User Interface), важной задачей является отделение внутренней логики приложения от его графической части. Применительно к языкам Java и Kotlin удобно, например, поместить внутреннюю логику в отдельный пакет и полностью абстрагировать её от графической части -- например, не применять классы и функции из пакетов `javafx` и `tornadofx` и их подпакетов. Это позволяет, в частности:

* разрабатывать и тестировать внутреннюю логику приложения отдельно от его графических функций
* менять графическую часть приложения (в том числе, используемую библиотеку) без значительного изменения внутренней логики

Общеизвестным *шаблоном* (pattern), реализующим подобную архитектуру, является https://ru.wikipedia.org/wiki/Model-View-Controller[MVC] = Model-View-Controller (модель-представление-контроллер). В этом шаблоне приложение предполагается делить даже не на две, а на три части:

* Модель описывает внутреннюю логику, используется и тестируется через её API
* Представление описывает, как информация из модели представляется пользователю -- для JavaFX-приложения это совокупность сцен и диалогов
* Контроллер описывает, как приложение реагирует на команды пользователю -- для JavaFX-приложения это совокупность слушателей

В соответствии с изображением ниже, контроллер изменяет модель, а представление обновляется в соответствии с моделью. При этом пользователь видит представление и использует контроллер для управления приложением.

image::https://upload.wikimedia.org/wikipedia/commons/thumb/f/fd/MVC-Process.png/240px-MVC-Process.png[MVC]

== Дополнительное чтение

* https://openjfx.io/openjfx-docs/[Getting started with JavaFX]
* https://www.jetbrains.com/help/idea/javafx.html[IDEA: Create a new JavaFX project]
* https://www.tutorialspoint.com/javafx/javafx_application.htm[Tutorials' Point: JavaFX Application]
* https://docs.oracle.com/javafx/2/scenegraph/jfxpub-scenegraph.htm[Oracle: Working with the JavaFX Scene Graph]
* https://docs.oracle.com/javase/8/javafx/properties-binding-tutorial/binding.htm[Oracle: Using JavaFX Properties and Binding]

